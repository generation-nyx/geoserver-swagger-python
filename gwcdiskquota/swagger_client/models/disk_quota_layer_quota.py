# coding: utf-8

"""
    GeoWebCache DiskQuota

    The REST API for Disk Quota management provides a RESTful interface through which clients can configure the disk usage limits and expiration policies for a GeoWebCache instance through simple HTTP calls.  Since disk usage increases geometrically by zoom level, one single seeding task could fill up an entire storage device. Because of this, GeoWebCache employs a disk quota system where one can specify the maximum amount of disk space to use for a particular layer, as well as logic on how to proceed when that quota is reached. There are two different policies for managing the disk quotas - Least Frequently Used (LFU) and Least Recently Used (LRU).  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: geoserver-users@sourceforge.net
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.configuration import Configuration


class DiskQuotaLayerQuota(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'layer': 'str',
        'expiration_policy_name': 'str',
        'quota': 'DiskQuotaLayerQuotaQuota'
    }

    attribute_map = {
        'layer': 'layer',
        'expiration_policy_name': 'expirationPolicyName',
        'quota': 'quota'
    }

    def __init__(self, layer=None, expiration_policy_name=None, quota=None, _configuration=None):  # noqa: E501
        """DiskQuotaLayerQuota - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._layer = None
        self._expiration_policy_name = None
        self._quota = None
        self.discriminator = None

        if layer is not None:
            self.layer = layer
        if expiration_policy_name is not None:
            self.expiration_policy_name = expiration_policy_name
        if quota is not None:
            self.quota = quota

    @property
    def layer(self):
        """Gets the layer of this DiskQuotaLayerQuota.  # noqa: E501

        The layer name.  # noqa: E501

        :return: The layer of this DiskQuotaLayerQuota.  # noqa: E501
        :rtype: str
        """
        return self._layer

    @layer.setter
    def layer(self, layer):
        """Sets the layer of this DiskQuotaLayerQuota.

        The layer name.  # noqa: E501

        :param layer: The layer of this DiskQuotaLayerQuota.  # noqa: E501
        :type: str
        """

        self._layer = layer

    @property
    def expiration_policy_name(self):
        """Gets the expiration_policy_name of this DiskQuotaLayerQuota.  # noqa: E501

        When a disk quota is reached, further tiles will be saved at the expense of other tiles which will be truncated. The Least Frequently Used (LFU) policy will analyze the disk quota page store and delete the pages of tiles that have been accessed the least often. The Least Recently Used (LRU) policy will analyze the diskquota page store and delete the tiles that haven’t been accessed in the longest amount of time.  # noqa: E501

        :return: The expiration_policy_name of this DiskQuotaLayerQuota.  # noqa: E501
        :rtype: str
        """
        return self._expiration_policy_name

    @expiration_policy_name.setter
    def expiration_policy_name(self, expiration_policy_name):
        """Sets the expiration_policy_name of this DiskQuotaLayerQuota.

        When a disk quota is reached, further tiles will be saved at the expense of other tiles which will be truncated. The Least Frequently Used (LFU) policy will analyze the disk quota page store and delete the pages of tiles that have been accessed the least often. The Least Recently Used (LRU) policy will analyze the diskquota page store and delete the tiles that haven’t been accessed in the longest amount of time.  # noqa: E501

        :param expiration_policy_name: The expiration_policy_name of this DiskQuotaLayerQuota.  # noqa: E501
        :type: str
        """
        allowed_values = ["LRU", "LSU"]  # noqa: E501
        if (self._configuration.client_side_validation and
                expiration_policy_name not in allowed_values):
            raise ValueError(
                "Invalid value for `expiration_policy_name` ({0}), must be one of {1}"  # noqa: E501
                .format(expiration_policy_name, allowed_values)
            )

        self._expiration_policy_name = expiration_policy_name

    @property
    def quota(self):
        """Gets the quota of this DiskQuotaLayerQuota.  # noqa: E501


        :return: The quota of this DiskQuotaLayerQuota.  # noqa: E501
        :rtype: DiskQuotaLayerQuotaQuota
        """
        return self._quota

    @quota.setter
    def quota(self, quota):
        """Sets the quota of this DiskQuotaLayerQuota.


        :param quota: The quota of this DiskQuotaLayerQuota.  # noqa: E501
        :type: DiskQuotaLayerQuotaQuota
        """

        self._quota = quota

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(DiskQuotaLayerQuota, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, DiskQuotaLayerQuota):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, DiskQuotaLayerQuota):
            return True

        return self.to_dict() != other.to_dict()
