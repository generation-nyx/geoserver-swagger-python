# coding: utf-8

"""
    GeoWebCache DiskQuota

    The REST API for Disk Quota management provides a RESTful interface through which clients can configure the disk usage limits and expiration policies for a GeoWebCache instance through simple HTTP calls.  Since disk usage increases geometrically by zoom level, one single seeding task could fill up an entire storage device. Because of this, GeoWebCache employs a disk quota system where one can specify the maximum amount of disk space to use for a particular layer, as well as logic on how to proceed when that quota is reached. There are two different policies for managing the disk quotas - Least Frequently Used (LFU) and Least Recently Used (LRU).  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: geoserver-users@sourceforge.net
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.configuration import Configuration


class DiskQuota(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'enabled': 'bool',
        'disk_block_size': 'float',
        'cache_clean_up_frequency': 'float',
        'cache_clean_up_units': 'str',
        'max_concurrent_clean_ups': 'float',
        'global_expiration_policy_name': 'str',
        'global_quota': 'DiskQuotaGlobalQuota',
        'layer_quota': 'DiskQuotaLayerQuota'
    }

    attribute_map = {
        'enabled': 'enabled',
        'disk_block_size': 'diskBlockSize',
        'cache_clean_up_frequency': 'cacheCleanUpFrequency',
        'cache_clean_up_units': 'cacheCleanUpUnits',
        'max_concurrent_clean_ups': 'maxConcurrentCleanUps',
        'global_expiration_policy_name': 'globalExpirationPolicyName',
        'global_quota': 'globalQuota',
        'layer_quota': 'layerQuota'
    }

    def __init__(self, enabled=None, disk_block_size=None, cache_clean_up_frequency=None, cache_clean_up_units=None, max_concurrent_clean_ups=None, global_expiration_policy_name=None, global_quota=None, layer_quota=None, _configuration=None):  # noqa: E501
        """DiskQuota - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._enabled = None
        self._disk_block_size = None
        self._cache_clean_up_frequency = None
        self._cache_clean_up_units = None
        self._max_concurrent_clean_ups = None
        self._global_expiration_policy_name = None
        self._global_quota = None
        self._layer_quota = None
        self.discriminator = None

        if enabled is not None:
            self.enabled = enabled
        if disk_block_size is not None:
            self.disk_block_size = disk_block_size
        if cache_clean_up_frequency is not None:
            self.cache_clean_up_frequency = cache_clean_up_frequency
        if cache_clean_up_units is not None:
            self.cache_clean_up_units = cache_clean_up_units
        if max_concurrent_clean_ups is not None:
            self.max_concurrent_clean_ups = max_concurrent_clean_ups
        if global_expiration_policy_name is not None:
            self.global_expiration_policy_name = global_expiration_policy_name
        if global_quota is not None:
            self.global_quota = global_quota
        if layer_quota is not None:
            self.layer_quota = layer_quota

    @property
    def enabled(self):
        """Gets the enabled of this DiskQuota.  # noqa: E501

        Determines if Disk Quota is to be used.  # noqa: E501

        :return: The enabled of this DiskQuota.  # noqa: E501
        :rtype: bool
        """
        return self._enabled

    @enabled.setter
    def enabled(self, enabled):
        """Sets the enabled of this DiskQuota.

        Determines if Disk Quota is to be used.  # noqa: E501

        :param enabled: The enabled of this DiskQuota.  # noqa: E501
        :type: bool
        """

        self._enabled = enabled

    @property
    def disk_block_size(self):
        """Gets the disk_block_size of this DiskQuota.  # noqa: E501

        The number of bytes allocated to Disk Quota.  # noqa: E501

        :return: The disk_block_size of this DiskQuota.  # noqa: E501
        :rtype: float
        """
        return self._disk_block_size

    @disk_block_size.setter
    def disk_block_size(self, disk_block_size):
        """Sets the disk_block_size of this DiskQuota.

        The number of bytes allocated to Disk Quota.  # noqa: E501

        :param disk_block_size: The disk_block_size of this DiskQuota.  # noqa: E501
        :type: float
        """

        self._disk_block_size = disk_block_size

    @property
    def cache_clean_up_frequency(self):
        """Gets the cache_clean_up_frequency of this DiskQuota.  # noqa: E501

        GeoWebCache will not truncate the cache as soon as the disk quota is exceeded. Instead, it polls the store at given intervals, with this time interval set.  # noqa: E501

        :return: The cache_clean_up_frequency of this DiskQuota.  # noqa: E501
        :rtype: float
        """
        return self._cache_clean_up_frequency

    @cache_clean_up_frequency.setter
    def cache_clean_up_frequency(self, cache_clean_up_frequency):
        """Sets the cache_clean_up_frequency of this DiskQuota.

        GeoWebCache will not truncate the cache as soon as the disk quota is exceeded. Instead, it polls the store at given intervals, with this time interval set.  # noqa: E501

        :param cache_clean_up_frequency: The cache_clean_up_frequency of this DiskQuota.  # noqa: E501
        :type: float
        """

        self._cache_clean_up_frequency = cache_clean_up_frequency

    @property
    def cache_clean_up_units(self):
        """Gets the cache_clean_up_units of this DiskQuota.  # noqa: E501

        The time unit used to describe the number in cacheCleanUpFrequency.  # noqa: E501

        :return: The cache_clean_up_units of this DiskQuota.  # noqa: E501
        :rtype: str
        """
        return self._cache_clean_up_units

    @cache_clean_up_units.setter
    def cache_clean_up_units(self, cache_clean_up_units):
        """Sets the cache_clean_up_units of this DiskQuota.

        The time unit used to describe the number in cacheCleanUpFrequency.  # noqa: E501

        :param cache_clean_up_units: The cache_clean_up_units of this DiskQuota.  # noqa: E501
        :type: str
        """
        allowed_values = ["SECONDS", "MINUTES", "HOURS", "DAYS"]  # noqa: E501
        if (self._configuration.client_side_validation and
                cache_clean_up_units not in allowed_values):
            raise ValueError(
                "Invalid value for `cache_clean_up_units` ({0}), must be one of {1}"  # noqa: E501
                .format(cache_clean_up_units, allowed_values)
            )

        self._cache_clean_up_units = cache_clean_up_units

    @property
    def max_concurrent_clean_ups(self):
        """Gets the max_concurrent_clean_ups of this DiskQuota.  # noqa: E501

        The amount of threads to use when processing the disk quota.  # noqa: E501

        :return: The max_concurrent_clean_ups of this DiskQuota.  # noqa: E501
        :rtype: float
        """
        return self._max_concurrent_clean_ups

    @max_concurrent_clean_ups.setter
    def max_concurrent_clean_ups(self, max_concurrent_clean_ups):
        """Sets the max_concurrent_clean_ups of this DiskQuota.

        The amount of threads to use when processing the disk quota.  # noqa: E501

        :param max_concurrent_clean_ups: The max_concurrent_clean_ups of this DiskQuota.  # noqa: E501
        :type: float
        """

        self._max_concurrent_clean_ups = max_concurrent_clean_ups

    @property
    def global_expiration_policy_name(self):
        """Gets the global_expiration_policy_name of this DiskQuota.  # noqa: E501

        When a disk quota is reached, further tiles will be saved at the expense of other tiles which will be truncated. The Least Frequently Used (LFU) policy will analyze the disk quota page store and delete the pages of tiles that have been accessed the least often. The Least Recently Used (LRU) policy will analyze the diskquota page store and delete the tiles that haven’t been accessed in the longest amount of time.  # noqa: E501

        :return: The global_expiration_policy_name of this DiskQuota.  # noqa: E501
        :rtype: str
        """
        return self._global_expiration_policy_name

    @global_expiration_policy_name.setter
    def global_expiration_policy_name(self, global_expiration_policy_name):
        """Sets the global_expiration_policy_name of this DiskQuota.

        When a disk quota is reached, further tiles will be saved at the expense of other tiles which will be truncated. The Least Frequently Used (LFU) policy will analyze the disk quota page store and delete the pages of tiles that have been accessed the least often. The Least Recently Used (LRU) policy will analyze the diskquota page store and delete the tiles that haven’t been accessed in the longest amount of time.  # noqa: E501

        :param global_expiration_policy_name: The global_expiration_policy_name of this DiskQuota.  # noqa: E501
        :type: str
        """
        allowed_values = ["LRU", "LSU"]  # noqa: E501
        if (self._configuration.client_side_validation and
                global_expiration_policy_name not in allowed_values):
            raise ValueError(
                "Invalid value for `global_expiration_policy_name` ({0}), must be one of {1}"  # noqa: E501
                .format(global_expiration_policy_name, allowed_values)
            )

        self._global_expiration_policy_name = global_expiration_policy_name

    @property
    def global_quota(self):
        """Gets the global_quota of this DiskQuota.  # noqa: E501


        :return: The global_quota of this DiskQuota.  # noqa: E501
        :rtype: DiskQuotaGlobalQuota
        """
        return self._global_quota

    @global_quota.setter
    def global_quota(self, global_quota):
        """Sets the global_quota of this DiskQuota.


        :param global_quota: The global_quota of this DiskQuota.  # noqa: E501
        :type: DiskQuotaGlobalQuota
        """

        self._global_quota = global_quota

    @property
    def layer_quota(self):
        """Gets the layer_quota of this DiskQuota.  # noqa: E501


        :return: The layer_quota of this DiskQuota.  # noqa: E501
        :rtype: DiskQuotaLayerQuota
        """
        return self._layer_quota

    @layer_quota.setter
    def layer_quota(self, layer_quota):
        """Sets the layer_quota of this DiskQuota.


        :param layer_quota: The layer_quota of this DiskQuota.  # noqa: E501
        :type: DiskQuotaLayerQuota
        """

        self._layer_quota = layer_quota

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(DiskQuota, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, DiskQuota):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, DiskQuota):
            return True

        return self.to_dict() != other.to_dict()
