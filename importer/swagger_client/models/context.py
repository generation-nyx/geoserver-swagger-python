# coding: utf-8

"""
    GeoServer Importer Extension - Main

    The Importer extension gives a GeoServer administrator an alternate, more-streamlined method for uploading and configuring new layers. The main endpoint manages individual import jobs. The importer extension is an optional install and may not be available on all deployments of GeoServer  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: geoserver-users@sourceforge.net
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.configuration import Configuration


class Context(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'id': 'str',
        'href': 'str',
        'state': 'str',
        'message': 'str',
        'archive': 'bool',
        'target_workspace': 'str',
        'target_store': 'Store',
        'data': 'Data',
        'transforms': 'Transforms',
        'tasks': 'Tasks'
    }

    attribute_map = {
        'id': 'id',
        'href': 'href',
        'state': 'state',
        'message': 'message',
        'archive': 'archive',
        'target_workspace': 'targetWorkspace',
        'target_store': 'targetStore',
        'data': 'data',
        'transforms': 'transforms',
        'tasks': 'tasks'
    }

    def __init__(self, id=None, href=None, state=None, message=None, archive=None, target_workspace=None, target_store=None, data=None, transforms=None, tasks=None, _configuration=None):  # noqa: E501
        """Context - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._id = None
        self._href = None
        self._state = None
        self._message = None
        self._archive = None
        self._target_workspace = None
        self._target_store = None
        self._data = None
        self._transforms = None
        self._tasks = None
        self.discriminator = None

        if id is not None:
            self.id = id
        if href is not None:
            self.href = href
        if state is not None:
            self.state = state
        if message is not None:
            self.message = message
        if archive is not None:
            self.archive = archive
        if target_workspace is not None:
            self.target_workspace = target_workspace
        if target_store is not None:
            self.target_store = target_store
        if data is not None:
            self.data = data
        if transforms is not None:
            self.transforms = transforms
        if tasks is not None:
            self.tasks = tasks

    @property
    def id(self):
        """Gets the id of this Context.  # noqa: E501

        The import id  # noqa: E501

        :return: The id of this Context.  # noqa: E501
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this Context.

        The import id  # noqa: E501

        :param id: The id of this Context.  # noqa: E501
        :type: str
        """

        self._id = id

    @property
    def href(self):
        """Gets the href of this Context.  # noqa: E501

        URL to the import context endpoint  # noqa: E501

        :return: The href of this Context.  # noqa: E501
        :rtype: str
        """
        return self._href

    @href.setter
    def href(self, href):
        """Sets the href of this Context.

        URL to the import context endpoint  # noqa: E501

        :param href: The href of this Context.  # noqa: E501
        :type: str
        """

        self._href = href

    @property
    def state(self):
        """Gets the state of this Context.  # noqa: E501

        State of the import.  # noqa: E501

        :return: The state of this Context.  # noqa: E501
        :rtype: str
        """
        return self._state

    @state.setter
    def state(self, state):
        """Sets the state of this Context.

        State of the import.  # noqa: E501

        :param state: The state of this Context.  # noqa: E501
        :type: str
        """
        allowed_values = ["INIT", "INIT_ERROR", "PENDING", "RUNNING", "COMPLETE"]  # noqa: E501
        if (self._configuration.client_side_validation and
                state not in allowed_values):
            raise ValueError(
                "Invalid value for `state` ({0}), must be one of {1}"  # noqa: E501
                .format(state, allowed_values)
            )

        self._state = state

    @property
    def message(self):
        """Gets the message of this Context.  # noqa: E501

        The current context message, if any  # noqa: E501

        :return: The message of this Context.  # noqa: E501
        :rtype: str
        """
        return self._message

    @message.setter
    def message(self, message):
        """Sets the message of this Context.

        The current context message, if any  # noqa: E501

        :param message: The message of this Context.  # noqa: E501
        :type: str
        """

        self._message = message

    @property
    def archive(self):
        """Gets the archive of this Context.  # noqa: E501

        Flag to control whether imported files (indirect) should be archived after import  # noqa: E501

        :return: The archive of this Context.  # noqa: E501
        :rtype: bool
        """
        return self._archive

    @archive.setter
    def archive(self, archive):
        """Sets the archive of this Context.

        Flag to control whether imported files (indirect) should be archived after import  # noqa: E501

        :param archive: The archive of this Context.  # noqa: E501
        :type: bool
        """

        self._archive = archive

    @property
    def target_workspace(self):
        """Gets the target_workspace of this Context.  # noqa: E501

        Target workspace of the import, if any.  # noqa: E501

        :return: The target_workspace of this Context.  # noqa: E501
        :rtype: str
        """
        return self._target_workspace

    @target_workspace.setter
    def target_workspace(self, target_workspace):
        """Sets the target_workspace of this Context.

        Target workspace of the import, if any.  # noqa: E501

        :param target_workspace: The target_workspace of this Context.  # noqa: E501
        :type: str
        """

        self._target_workspace = target_workspace

    @property
    def target_store(self):
        """Gets the target_store of this Context.  # noqa: E501


        :return: The target_store of this Context.  # noqa: E501
        :rtype: Store
        """
        return self._target_store

    @target_store.setter
    def target_store(self, target_store):
        """Sets the target_store of this Context.


        :param target_store: The target_store of this Context.  # noqa: E501
        :type: Store
        """

        self._target_store = target_store

    @property
    def data(self):
        """Gets the data of this Context.  # noqa: E501


        :return: The data of this Context.  # noqa: E501
        :rtype: Data
        """
        return self._data

    @data.setter
    def data(self, data):
        """Sets the data of this Context.


        :param data: The data of this Context.  # noqa: E501
        :type: Data
        """

        self._data = data

    @property
    def transforms(self):
        """Gets the transforms of this Context.  # noqa: E501


        :return: The transforms of this Context.  # noqa: E501
        :rtype: Transforms
        """
        return self._transforms

    @transforms.setter
    def transforms(self, transforms):
        """Sets the transforms of this Context.


        :param transforms: The transforms of this Context.  # noqa: E501
        :type: Transforms
        """

        self._transforms = transforms

    @property
    def tasks(self):
        """Gets the tasks of this Context.  # noqa: E501


        :return: The tasks of this Context.  # noqa: E501
        :rtype: Tasks
        """
        return self._tasks

    @tasks.setter
    def tasks(self, tasks):
        """Sets the tasks of this Context.


        :param tasks: The tasks of this Context.  # noqa: E501
        :type: Tasks
        """

        self._tasks = tasks

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Context, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Context):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, Context):
            return True

        return self.to_dict() != other.to_dict()
