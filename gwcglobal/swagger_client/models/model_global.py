# coding: utf-8

"""
    GeoWebCache Global

    Global configuration for the GeoWebCache server  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: geoserver-users@sourceforge.net
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.configuration import Configuration


class ModelGlobal(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'service_information': 'ServiceInformation',
        'runtime_stats_enabled': 'bool',
        'wmts_cite_compliant': 'bool',
        'backend_timeout': 'int',
        'version': 'str',
        'identifier': 'str',
        'location': 'str'
    }

    attribute_map = {
        'service_information': 'serviceInformation',
        'runtime_stats_enabled': 'runtimeStatsEnabled',
        'wmts_cite_compliant': 'wmtsCiteCompliant',
        'backend_timeout': 'backendTimeout',
        'version': 'version',
        'identifier': 'identifier',
        'location': 'location'
    }

    def __init__(self, service_information=None, runtime_stats_enabled=None, wmts_cite_compliant=None, backend_timeout=None, version=None, identifier=None, location=None, _configuration=None):  # noqa: E501
        """ModelGlobal - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._service_information = None
        self._runtime_stats_enabled = None
        self._wmts_cite_compliant = None
        self._backend_timeout = None
        self._version = None
        self._identifier = None
        self._location = None
        self.discriminator = None

        if service_information is not None:
            self.service_information = service_information
        if runtime_stats_enabled is not None:
            self.runtime_stats_enabled = runtime_stats_enabled
        if wmts_cite_compliant is not None:
            self.wmts_cite_compliant = wmts_cite_compliant
        if backend_timeout is not None:
            self.backend_timeout = backend_timeout
        if version is not None:
            self.version = version
        if identifier is not None:
            self.identifier = identifier
        if location is not None:
            self.location = location

    @property
    def service_information(self):
        """Gets the service_information of this ModelGlobal.  # noqa: E501


        :return: The service_information of this ModelGlobal.  # noqa: E501
        :rtype: ServiceInformation
        """
        return self._service_information

    @service_information.setter
    def service_information(self, service_information):
        """Sets the service_information of this ModelGlobal.


        :param service_information: The service_information of this ModelGlobal.  # noqa: E501
        :type: ServiceInformation
        """

        self._service_information = service_information

    @property
    def runtime_stats_enabled(self):
        """Gets the runtime_stats_enabled of this ModelGlobal.  # noqa: E501

        Whether runtime statistics are being gathered. Runtime statistics run, by default, every three second and provide data about how many requests the system has been serving in the past 3, 15 and 60 seconds, as well as aggregate numbers.  # noqa: E501

        :return: The runtime_stats_enabled of this ModelGlobal.  # noqa: E501
        :rtype: bool
        """
        return self._runtime_stats_enabled

    @runtime_stats_enabled.setter
    def runtime_stats_enabled(self, runtime_stats_enabled):
        """Sets the runtime_stats_enabled of this ModelGlobal.

        Whether runtime statistics are being gathered. Runtime statistics run, by default, every three second and provide data about how many requests the system has been serving in the past 3, 15 and 60 seconds, as well as aggregate numbers.  # noqa: E501

        :param runtime_stats_enabled: The runtime_stats_enabled of this ModelGlobal.  # noqa: E501
        :type: bool
        """

        self._runtime_stats_enabled = runtime_stats_enabled

    @property
    def wmts_cite_compliant(self):
        """Gets the wmts_cite_compliant of this ModelGlobal.  # noqa: E501

        Whether the server is running in WMTS strict compliance mode.  # noqa: E501

        :return: The wmts_cite_compliant of this ModelGlobal.  # noqa: E501
        :rtype: bool
        """
        return self._wmts_cite_compliant

    @wmts_cite_compliant.setter
    def wmts_cite_compliant(self, wmts_cite_compliant):
        """Sets the wmts_cite_compliant of this ModelGlobal.

        Whether the server is running in WMTS strict compliance mode.  # noqa: E501

        :param wmts_cite_compliant: The wmts_cite_compliant of this ModelGlobal.  # noqa: E501
        :type: bool
        """

        self._wmts_cite_compliant = wmts_cite_compliant

    @property
    def backend_timeout(self):
        """Gets the backend_timeout of this ModelGlobal.  # noqa: E501

        The number of seconds GWC will wait for a backend server to return something before closing the connection.  # noqa: E501

        :return: The backend_timeout of this ModelGlobal.  # noqa: E501
        :rtype: int
        """
        return self._backend_timeout

    @backend_timeout.setter
    def backend_timeout(self, backend_timeout):
        """Sets the backend_timeout of this ModelGlobal.

        The number of seconds GWC will wait for a backend server to return something before closing the connection.  # noqa: E501

        :param backend_timeout: The backend_timeout of this ModelGlobal.  # noqa: E501
        :type: int
        """

        self._backend_timeout = backend_timeout

    @property
    def version(self):
        """Gets the version of this ModelGlobal.  # noqa: E501

        The GeoWebCache version. Read-only.  # noqa: E501

        :return: The version of this ModelGlobal.  # noqa: E501
        :rtype: str
        """
        return self._version

    @version.setter
    def version(self, version):
        """Sets the version of this ModelGlobal.

        The GeoWebCache version. Read-only.  # noqa: E501

        :param version: The version of this ModelGlobal.  # noqa: E501
        :type: str
        """

        self._version = version

    @property
    def identifier(self):
        """Gets the identifier of this ModelGlobal.  # noqa: E501

        The unique identifier for this global server configuration. Read-only.  # noqa: E501

        :return: The identifier of this ModelGlobal.  # noqa: E501
        :rtype: str
        """
        return self._identifier

    @identifier.setter
    def identifier(self, identifier):
        """Sets the identifier of this ModelGlobal.

        The unique identifier for this global server configuration. Read-only.  # noqa: E501

        :param identifier: The identifier of this ModelGlobal.  # noqa: E501
        :type: str
        """

        self._identifier = identifier

    @property
    def location(self):
        """Gets the location of this ModelGlobal.  # noqa: E501

        The location of this configuration. Read-only.  # noqa: E501

        :return: The location of this ModelGlobal.  # noqa: E501
        :rtype: str
        """
        return self._location

    @location.setter
    def location(self, location):
        """Sets the location of this ModelGlobal.

        The location of this configuration. Read-only.  # noqa: E501

        :param location: The location of this ModelGlobal.  # noqa: E501
        :type: str
        """

        self._location = location

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(ModelGlobal, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ModelGlobal):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, ModelGlobal):
            return True

        return self.to_dict() != other.to_dict()
